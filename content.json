[{"title":"Angular 和 React 比较","date":"2017-02-21T09:36:37.864Z","path":"2017/02/21/Angular和React比较/","text":"Angular的优缺点：优点 Angular是一套完整的框架，angular有自带的数据绑定、render渲染、angularUI库,过滤器,directive(模板),服务q(defer),http，inject(依赖注入),factory,provider……，等等一系列工具，基本上只要你在做web开发用过的东西，它都有一个。但是这些东西React自身都没有。 Angularjs的架构清晰，分工明确，扩展性良好，model，view，controller谁在什么时候做什么事情说的很清楚，angular能够让程序员真正专注于业务逻辑，而且因为对html侵入不大，非常易于和designer协作。整个框架充满了DI的思路，耦合性非常低，对象都是被inject的，也就是说每个对象都可以轻易被替换而不影响其他对象。 Angular生产效率高，单向数据流什么的想法非常好，但是写起来太麻烦！我只想变更个很简单的数据还要经过action、dispatcher、reduce、view四步，angular里一行代码就搞定的事情在react里却如此麻烦 缺点 性能 双向数据绑定是一把双刃剑。随着组件增加，项目越来越复杂，双向数据绑定带来性能问题。双向数据绑定是如何影响性能的？在JavaScript（ES5）中，并没有实现当变量或对象改变时发出通知的功能，Angular的实现方法被叫做“Dirty-checking（脏检查机制）”，通过跟踪数据的改变再动态更新用户界面（UI）。在Angular的作用域中任何操作的执行都会引发Dirty-checking，随着绑定数量的增加性能就会越低。 Angular 2.0推翻重做使得目前不宜采用此框架Angular 1.x版本其实是个比较旧的东西了，现在看来有些理念过时了，比如依赖注入、自己独特的模块化，这些东西其实在ES6下已经很好地被解决了。Angular的2.0几乎是一个推翻重做的框架，估计不会有1.X的upgrade方案。所以如果现在新开始的项目采用Angular的话，会是一个很尴尬的时机。同样，如此大的改动似乎也反面印证了1.X并不是那么好。 学习成本高使用Angular需要学习大量的概念，包括但不限于： 模块 控制器 指令 作用域 模板 链式函数 过滤器 依赖注入 React的优缺点 React伟大之处就在于，提出了Virtual Dom这种新颖的思路，并且这种思路衍生出了React Native，有可能会统一Web/Native开发。在性能方面，由于运用了Virtual Dom技术，Reactjs只在调用setState的时候会更新dom，而且还是先更新Virtual Dom，然后和实际Dom比较，最后再更新实际Dom。这个过程比起Angularjs的bind方式来说，一是更新dom的次数少，二是更新dom的内容少，速度肯定快 ReactJS更关注UI的组件化，和数据的单向更新，提出了FLUX架构的新概念，现在React可以直接用Js ES6语法了，然后通过webpack编译成浏览器兼容的ES5，开发效率上有些优势. React Native生成的App不是运行在WebView上，而是系统原生的UI，React通过jsx生成系统原生的UI，iOS和Android的React UI组件还是比较相似的，大量代码可以复用 维护UI的状态,Angular 里面使用的是 $scope，在 React 里面使用的是 this.setState。 而 React 的好处在于，它更简单直观。所有的状态改变都只有唯一一个入口 this.setState()，Angular 就比较复杂，不知道背后使用了哪些黑魔法。 同构的JavaScript单页面JS应用程序的最大缺陷在于对搜索引擎的索引有很大限制。React对此有了解决方案。React可以在服务器上预渲染应用再发送到客户端。它可以从预渲染的静态内容中恢复一样的记录到动态应用程序中。因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。 缺点 React是目标是UI组件，通常可以和其它框架组合使用，目前并不适合单独做一个完整的框架。React 即使配上 redux 的组合，也不能称之一个完整的框架，比如你想用Promise化的AJAX？对不起没有，自己找现成的库去。而且第三方组件远远不如Angular多。目前在大的稳定的项目上采用React的，我也就只知道有Yahoo的Email。React本身只是一个V而已，所以如果是大型项目想要一套完整的框架的话，也许还需要引入Redux和route相关的东西。而Angular在这方面提供的东西比React多多了.","tags":[]},{"title":"AngularJs性能优化的问题","date":"2017-02-21T09:36:37.858Z","path":"2017/02/21/AngularJs性能优化总结/","text":"一、减少双向绑定 我们知道AngularJS的双向数据绑定是通过为每个需要双向绑定的数据对象添加watchers，一旦某个scope的数据发生了更新，就触发脏检查（$digest），深度优先遍历需所有scope对象的watchers值的old/new value是否发生变化。所以在开发过程中，我们都要小心判断出每个watchers是否有必要。对于只需要更新一次，以后不管数据层如何变化都不需要更新的数据，使用连续两个冒号即可在watchers列表中将这个值删除，即减少了$digest脏检查循环。 二、ng-repeat优化 虽然第一种方式减少了脏检查的次数，但是单次绑定的数据毕竟少数，可能加完单次绑定，性能提升并没有太大变化。如果我们的代码中使用了ng-repeat，并且list的数量很大时，我们的性能会有很大下降，在移动端尤为明显。 下面是对ng-repeat指令的优化： 使用limitTo来减少第一次加载列表元素的数量，以提高初始化页面的速度，也许我们有上百上千条数据要显示i，但是屏幕大小有限，呈现给客户的也就是1280800或者360640大小的屏幕，所以我们可以先加载用户能看到的几个列表。limitTo属性就提供了这样的功能。 使用track by属性。需要注意的是limitTo和track by一起使用时，track by要放到最后。如果有引入ionic框架，可以使用collection-repeat替代ng-repeat。collection-repeat是ionic框架自己的一套显示list的指令，原理在于不论list有多大，页面最多只有一定数量的item,这个item数量的大小是通过屏幕高度和单个item的高度计算出来的。滑动列表时通过更新item元素的页面内容和位置来呈现所有的items。所以在大数量级的list呈现上，collection-repeat会比ng-repeat性能好很多。但是需要注意的是，由于collection-repeat是通过时时更新滑动位置的item内容来实现的，所以在item内部使用第一个方法的单次绑定方式，滑动后会造成页面混乱的情况。 三、减少HTML页面中的filter 原因是每当filter执行时，都会走两次$digest cycle，一次是scope中有数据改动，一次是查看是否有更多的改动需要更新数据。当数据量很大时对性能会有很大影响。我们可以在初始化时就格式化好数据，比如赋值到view层之前，在我们的js代码里使用angular提供的$filter provider来预处理我们的数据。 四、ng-if代替ng-show和ng-hide 原因是n-if与ng-show/ng-hide的不同之处在于，ng-if在等于false时会把元素从DOM中移除，所以所有绑定在该元素上的handler会一同失效。而ng-show/ng-hide不会移除DOM元素，而是使用css style去隐藏/显示DOM元素，所以handlers会一直存在。 五、$scope.$apply()和$scope.$digest() 我们会用到上面两种去执行一次脏检测，刷新页面数据。区别就是$scope.$apply()会从$rootscope开始，深度优先遍历执行$digest循环，而$scope.$digest会从当前scope开始，往下层scope遍历脏检测。如果只是期望当前scope的数据更新，而不涉及到parent $scope，则可以使用$scope.$digest()。 六、angular animate 如果我们的项目引入了angular-animate.js的模块，那么在大部分使用了指令的元素上，animate里面的代码都会被执行，不管当前元素是否有应用css动画样式。这对我们页面上如果有大量数据频繁滑动，隐藏显示的时候会有比较明显的性能问题。如果我们对当前scope并没有渐入渐出等动画效果的时候，可以在当前scope初始化时加上$animate.enabled(false);当然，我们也可以对某个元素进行禁止动画的动作：$animate.enabled(element, false);","tags":[]},{"title":"git和svn","date":"2017-01-09T00:53:58.532Z","path":"2017/01/09/git和svn/","text":"svn特点: 简单，只是需要一个放代码的地方Git特点: 版本控制可以不依赖网络做任何事，对分支和合并有更好的支持。两者区别:1. git是分布式的，而svn不是。这是git和其他非分布式的版本控制系统（svn，cvs等）最核心的区别。Git并不是目前唯一的分布式版本控制系统，如Bitkeeper, Mercurial等，也是运行在分布式模式上的。但git在在这方面做的更好，而且还拥有更多强大的功能特征。Git和SVN一样拥有自己的集中式版本库或服务器。只是git更倾向于分布式模式，即每个开发人员从中心版本库/服务端上chect out代码后会在自己的电脑上克隆一个自己的版本库。可以在没有网络的情况下，commit文件，查看历史版本记录，创建项目分支等。 2. git 把内容按元数据方式存储，而svn是按文件。所有的资源控制系统都是把文件的元信息隐藏在一个类似SVN等的文件夹中。Git目录的体积大小和SVN差距很大。因为Git目录是处于你的电脑上的一个克隆的版本库，他拥有中心版本库上的所有东西（标签，分支，版本记录等）。 3. git没有一个全局版本号，而svn有。这是目前为止git相比SVN缺少最大的一个特征。4. git 的内容的完整性要优于svn。GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏 5. git下载下来后，在OffLine状态下可以看到所有的Log, svn不可以。6. 刚开始用时SVN必须先Update才能Commit,忘记了合并时就会出现一些错误，git还是比较少的出现这种情况。7. 克隆一份全新的目录以同样拥有五个分支来说，SVN是同时复制5个版本的文件,也就是说重复五次同样的动作。而Git只是获取文件的每个版本的元素，然后只载入主要的分支(master)。8. SVN只能有一个指定中央版本库。当这个中央版本库有问题时，所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成。而 Git可以有无限个版本库。更正确的说法，每一个Git都是一个版本库，区别是它们是否拥有活跃目录（Git Working Tree）。9. 在SVN中分支是一个完整的目录。且这个目录拥有完整的实际文件。而 Git，每个工作成员可以任意在自己的本地版本库开啟无限个分支。10. 对于SVN，当你提交你的作品时，它会直接记录到中央版本库。当你发现你的作品存在问题时，你已经无法阻止。如果网路中断，则根本没办法提交！而git的提交完全属于本地版本库的活动。而你只需git push（推）到主要版本库即可。即“同步”（Sync）。 CaoLinlin","tags":[]},{"title":"git和github以及如何搭建自己的博客","date":"2017-01-07T05:35:08.828Z","path":"2017/01/07/git/","text":"一. GIT1. 什么是git Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。与常用的版本控制工具 CVS、Subversion等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 2. 源码是什么？ 在一个项目中，凡是由开发人员编写的代码都算是源代码。 3. 源代码为什么要管理起来？ 让代码可以被追溯，主要记录每次变更了什么，谁主导了这次的变化。协同开发，人为的维护比较麻烦。 4. git是谁做的？ -Git是linux之父（Linus Torvalds, 被誉为“活着的传奇”）为了维护管理Linux源码写的一个工具。 git之前很多使用svn, vss, tfs, hs….. git安装 安装相关的git客户端（命令行的） 安装界面化的git客户端SourceTress(tortoisegit, smartgit) 这里将只介绍命令行的安装 输入 git 检查是否已经安装过 git 在github官网下载正确的版本，一路安装即可。 然后以管理员身份打开cmd，git –servsion 检查git是否安装成功 git 命令清单Git基本命令包含查看、添加、提交、删除、找回、重置修改文件等等 git的简单使用1. 使用git init 初始化一个本地仓库 在本地文件夹中添加一个.git文件夹， 用于记录项目所有的变更信息。 2. git status 用于查看本地仓库的变更状态。第一次查看会显示未被跟踪的文件。 -s 参数: 输出简要的变更日志。 3. git add . 将没有被跟踪的文件添加到跟踪列表（git add –all） 4. 本地忽略清单 在.gitignore文件中添加相应的忽略清单 如：node modules /min 5. 提交 git commit 将本地的变化提交到本地的仓库文件夹归档 git commit -m “说明” （b必须you提交的日志） 6. git config git config –global user.email”you@example.com” git config –global user.name”your name” 7. git diff 比较当前文件和文件的状态 8. git log git log -p查看当前所有的提交 9. git reset –hard”哈希值” 将代码回归到之前的某个版本 总结 git 不需要服务器，但是协同开发时需要 git服务器，用来同步本地的代码仓库 git 是一个工具，github是一个网站（提供了远程仓库的功能） github网站提供的就是git服务（免费的服务，但是你提交的代码必须是开源的） 二. GitHubgithub 基本介绍[https://github.com] github是一个git服务的提供商（提出社交化编程） 创建用户 在github中创建一个账户，并且创建一个空的远程仓库 远程提交 git remote git remote add origin git@github.com:caocaolin/aaaa.git git push -u origin master git remote rm origin(删除远程仓库信息) 远程拉取 git clone （克隆相关的代码） git pull origin master （拉取最新的代码） 需要注意的是重新推入前要先拉取最新的代码 GitHub 页面的其他的功能gist 保留代码片段 git分支 git branch 查看分支 git branch ”分支名称“ 添加分支 git chexkout v2 切换到相应的分支 git push -u origin v2 推入到该分支 托管页面 分支名必须是 gh-pages hexo工具1. 使用npm安装hexo npm install -g hexo2. 初始化hexo hexo init blog3. 生成静态页面 hexo generate 4. 启动本地服务，进行文件预览调试 hexo server5. 修改 blog文件夹里面的 _config.yml文件 deploy: type: git repository: git@github.com:caocaolin/my_blog.git branch: gh-pages 6. 下载安装hexo-deployer-git npm install hexo-deployer-git –save7. 发布到github上 hexo deploy –generate**注意** : 打开网站会出现乱掉的情况，由于需要配置相应的路径 修改_config.yml文件 root:/ 重新发布 hexo clean hexo d g 关于yilia主题的使用怎样更换yilia主题头像 首先找到 G:\\my_blog\\blog\\themes\\yilia\\source\\img 把你要替换的头像放到该文件夹下，再找到 G:\\my_blog\\blog\\themes\\yilia _config.yml修改头像路径然后再在G:\\my_blog\\blog\\themes\\yilia&gt; \\layout_partial下面的 left-col.ejs, 用编辑器打开对如下进行编辑，再上传即可 把&lt;img src=&quot;&lt;%=theme.avatar%&gt;&quot; class=&quot;js-avatar show&quot;&gt;改为&lt;img src=&quot;&lt;%=theme.avatar%&gt;&quot; class=&quot;js-avatar show&quot; style=&quot;width: 100%;height: 100%;opacity: 1;&quot;&gt; 怎样切换yilia左侧头部背景 G:\\my_blog\\blog\\themes\\yilia\\layout_partial下面的left-col.ejs 的 &lt;% var defaultBg = ‘#99D9EA’; %&gt;** 模板里面的内容更改需要的颜色 G:\\my_blog\\blog\\themes\\yilia 下的 ——config.yml style: header更改为需要的颜色 重新部署后刷新页面可能需要短时间的等待 关于域名的问题 关于博客遇到的问题CNAME（域名映射问题）图片问题SSH路径展开全文的404错误每次重新上传都要hexo clean CaoLinlin","tags":[]},{"title":"welcome","date":"2017-01-06T13:00:30.873Z","path":"2017/01/06/demo/","text":"欢迎大家访问我的博客 希望大家多多提意见，共同进步哦！ CaoLinlin","tags":[]}]